package main.java.system;

import main.java.entities.Card;
import main.java.system.UID.ID;
import main.java.system.UID.IDGenerator;
import main.java.entities.transit.*;
import main.java.system.event.BusEventHandler;
import main.java.system.event.Event;
import main.java.system.event.SubwayEventHandler;
import main.java.system.metrics.Observable;
import main.java.users.Rider;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

/**
 * A class representing a public transportation system. Keeps track of all bus
 * and subway lines, as well as user information. Responsible for handling
 * inputs, such as events generated by a user tapping into or out of the system.
 */
public class TransitSystem extends Observable {
    private Rider[] cardholders;
    private BusLine[] busLines;
    private SubwayLine subwayLine;

    private DateTimeFormatter dtFormat = DateTimeFormatter.ofPattern("yyyy-MM-dd-HH:mm:ss");

    /**
     * Construct a new TransitSystem given a user base, a subway line, and a number
     * of bus lines
     *
     * @param cardholders the initial set of Riders who have cards for this network
     * @param busLines    the list of bus lines which are part of the system
     * @param subwayLine  the subway route which is in this network
     */
    public TransitSystem(Rider[] cardholders, BusLine[] busLines, SubwayLine subwayLine) {
        this.cardholders = cardholders;
        this.busLines = busLines;
        this.subwayLine = subwayLine;
    }

    /**
     * Returns the subway line in this system
     * 
     * @return this system's subway line
     */
    public SubwayLine getSubwayLine() {
        return this.subwayLine;
    }

    /**
     * Returns an array of all the bus lines in this system
     * 
     * @return this system's bus lines
     */
    public BusLine[] getBusLines() {
        return this.busLines;
    }

    /**
     * Returns an array of all the riders registered in this system
     * 
     * @return this system's cardholders
     */
    public Rider[] getCardholders() {
        return cardholders;
    }

    /**
     * Issues a new transit card to the given rider with the next sequential ID
     * 
     * @param rider the Rider to whom a new transit card will be issued
     */
    public Card issueCardToRider(Rider rider) {
        Card newCard = new Card(rider);

        rider.issueCard(newCard);

        return newCard;
    }

    /**
     * Returns the Bus Stop in the system corresponding to the given name and name
     * of line
     *
     * @param stopName the name of the bus stop
     * @param lineName the name of the line the stop is a part of
     * @return the stop with name stopName on line lineName. null if no such stop
     *         exists in the system
     */
    private BusStop findBusStopInSystem(String stopName, String lineName) {
        for (BusLine line : this.busLines) {
            if (line.getName().equals(lineName)) {
                return line.findStopOnLine(stopName);
            }
        }
        return null;
    }

    /**
     * Finds and returns the transit card in the system with the given id number
     * 
     * @param id the numerical id of the desired card
     * @return the Card with id: id. null if no such card is in the system
     */
    private Card findCardInSystem(ID id) {
        for (Rider rider : this.cardholders) {
            for (Card card : rider.getCards()) {
                if (card.getId().equals(id)) {
                    return card;
                }
            }
        }
        return null;
    }

    /**
     * Returns the Rider in this system with the given id
     * 
     * @param id the ID of the rider to be found
     * @return the rider with the given id, null if no such rider exists in this
     *         system
     */
    public Rider findRiderInSystem(ID id) {
        for (Rider rider : this.cardholders) {
            if (rider.getId().equals(id)) {
                return rider;
            }
        }
        return null;
    }

    /**
     * Parses the information from a text-based input, received from a card reader
     * in the system, into a tap Event in the system
     *
     * @param rawEvent the string containing the data about an event of the format
     *                 "[card id], [action], [stop], [line], [time]" where
     * 
     *                 <ul>
     *                 <li>[card] is the id of the card which was tapped</li>
     * 
     *                 <li>[action] is one of "enter" or "exit" (for subway events),
     *                 or "tap" (for events on a bus)</li>
     * 
     *                 <li>[stop] is the name of the stop at which this event
     *                 occurred</li>
     * 
     *                 <li>[line] is the name of the line on which this event
     *                 occurred ("subway" for subway)</li>
     * 
     *                 <li>[time] is the date and time of the tap, in the format
     *                 yyyy-mm-dd-hh:mm:ss (24 hr time)</li>
     *                 </ul>
     *
     * @return an Event with information corresponding to the data from the input
     *         string
     */
    private Event parseTapEvent(String rawEvent) {
        // <card id> <action> <stop> <line> <date-time>
        String[] tokens = rawEvent.split(", ");
        ID cardID = IDGenerator.findIDString(tokens[0]);
        Card card = this.findCardInSystem(cardID);
        LocalDateTime eventDateTime = LocalDateTime.parse(tokens[4], dtFormat);
        Event ret;

        if (tokens[1].equals("tap")) {
            BusStop busStop = this.findBusStopInSystem(tokens[2], tokens[3]);
            ret = new Event(busStop, eventDateTime, card);
        } else {
            SubwayStation station = this.subwayLine.findStopOnLine(tokens[2]);
            ret = new Event(station, eventDateTime, card, tokens[1]);
        }
        return ret;
    }

    /**
     * Processes a tap event in the transit system. Manages trips and charging for a
     * new tap event.
     * 
     * @param eventData the string representing the data from a tap event in the
     *                  system. This string must be able to be parsed by
     *                  parseTapEvent
     */
    public void handleTapEvent(String eventData) {
        Event event = this.parseTapEvent(eventData);
        Card card = event.getCard();
        Trip currentTrip;
        boolean hasBeenCharged;
        TransitStop loc = event.getLocation();
        boolean chargeable = false;

        if (event.getDirection() == null) {
            BusEventHandler busEventHandler = new BusEventHandler(event);
            currentTrip = busEventHandler.handleTap();

            if (currentTrip.getLatestEvent().isEntering()) {
                chargeable = true;
            } else {
                TransitLine currLine = currentTrip.getLatestEvent().getLocation().getLine();
                TransitStop prevLoc = currentTrip.getSecondLastEvent().getLocation();
                int numStops = currLine.getDistTraveled(prevLoc, loc);
                stopsPassed(currentTrip, numStops);
            }
        } else {
            SubwayEventHandler subwayEventHandler = new SubwayEventHandler(event);
            currentTrip = subwayEventHandler.handleTap();
            if (currentTrip != null) {
                chargeable = true;
            }
        }

        // if this was a good tap event process the charge
        if (chargeable) {
            hasBeenCharged = chargeRider(currentTrip);
            if (!hasBeenCharged) { // if the charge was not successful remove the event since it didn't go through
                Logger.error("Could not charge card.",
                        "You are either too low on funds or this card has been suspended.");
                card.removeLatestEventFromTrip(currentTrip);
            } else {
                // if we are exiting a subway, count stops
                if (loc.getClass() == SubwayStation.class) {
                    int numStops = loc.getLine().getDistTraveled(currentTrip.getSecondLastEvent().getLocation(), loc);
                    stopsPassed(currentTrip, numStops);
                }
            }
        }
    }

    /**
     * Charges the rider the correct amount for a tap event. The event to charge for
     * is the most recent event in the given trip.
     * 
     * @param trip the trip which contains the event we want to charge for
     * @return true if the rider was charged successully. That is, if the rider had
     *         the funds and the card was not suspended
     */
    private boolean chargeRider(Trip trip) {
        Event tap = trip.getLatestEvent();
        Card card = tap.getCard();

        float amount = 0;

        if (tap.getLocation().getClass() == SubwayStation.class) { // taps for a subway
            SubwayStation start = (SubwayStation) trip.getSecondLastEvent().getLocation();
            SubwayStation end = (SubwayStation) trip.getLatestEvent().getLocation();

            amount = subwayLine.getDistTraveled(start, end) * 0.5F;
        }

        if (tap.getLocation().getClass() == BusStop.class) {
            amount = 2;
            if (card.getBalance() < 2) {
                return false;
            }
        }

        float toCharge = trip.addCost(amount);
        boolean hasCharged = card.charge(toCharge);

        if (hasCharged) {
            String todayDate = getDate(tap);

            this.notifyObservers(todayDate, toCharge);
        }
        return hasCharged;
    }

    /**
     * Notifies the observers that n stops were travelled to. The event to look at
     * is the most recent event in the given trip.
     *
     * @param trip the trip which contains the event we want to account for
     * @param n    the number of stops travelled
     */
    private void stopsPassed(Trip trip, int n) {
        Event latestEvent = trip.getLatestEvent();
        String todayEvent = getDate(latestEvent);

        this.notifyObservers(todayEvent, n);
    }

    /**
     * Returns the date of when a given event occurred
     *
     * @param event the event we want the corresponding date for
     * @return the date that event took place on.
     */
    private String getDate(Event event) {
        LocalDateTime eventDate = event.getTimeStamp();

        int month = eventDate.getMonth().getValue();
        int day = eventDate.getDayOfMonth();
        int year = eventDate.getYear();
        String date = Integer.toString(month) + '/' + Integer.toString(day) + '/' + Integer.toString(year);

        return date;
    }
}
